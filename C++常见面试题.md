# C++常见面试题

1. 智能指针的作用

   将一般类型的指针包装成对象类型，利用对象生命周期到期时会调用析构函数自动完成资源的释放，防止内存泄露

2. 纯虚函数的作用和实现方式

   纯虚函数的作用是作为一个接口，子类必须实现这个接口，以表现出同一个接口却有不同的呈现，实现方式便是在纯虚函数的声明是在虚函数的声明后面加=0

3. STL数据结构的内部实现

   - 线性数据结构
     - vector 数组
     - array 数组
     - list 双向链表
     - forward_list 链表
     - deque 多段连续数组
   - 关联型数据结构
     - map 红黑树（键不重复）
     - multimap 红黑树（键可重复）
     - set 红黑树 （键不重复）
     - multiset 红黑树 （键可重复）
   - 无序型数据结构
     - unordered_map 哈希表（键不重复）
     - unordered_multimap 哈希表 （键可重复）
     - unordered_set 哈希表 （键不重复）
     - unordered_multiset 哈希表 （键可重复）

4. 红黑树插入和和红黑树的用途

   红黑树实现了查找与修改的平衡

5. C、C++、的区别以及C++的优势

   c++相当于c语言来说像一个语言联邦，它包含了c语言、面向对象、泛型编程、STL等成分，我暂时不知道如何何时的说出c++的优势，可能更简洁？

6. C++11的新特性有哪些？

   1. lambda表达式
   2. 智能指针
   3. 函数式编程
   4. tuple
   5. 类型转换
   6. 右值引用与移动构造函数
   7. 略略略

7. 指针和引用的区别，引用需要释放内存么

   - 引用必须初始化，指针不是必须的，而且引用绑定到一个对象上后，便不能再绑定到其他对象
   - 指针是一个变量，引用只是变量的别名

   不用释放内存

8. 智能指针的底层实现

9. 虚函数的底层实现

   虚指针加虚函数表

10. define的特点，预处理进行替换及define的优缺点

    - define在编译的预处理阶段起作用
    - define只是简单的字符串替换，没有类型检查
    - define是不能调试的

11. static作用

    - 修饰局部变量，使其生命周期持续到程序结束，且只有一次的初始化，存储于静态存储区
    - 修饰全局变量，使变量仅在当前文件可见
    - 修饰一般函数，使函数仅在当前文件可见
    - 修饰类成员变量，使其所有权属于类，所有对象使用同一个成员变量
    - 修饰成员函数，同上

12. new和malloc的区别

    - malloc是c的库函数，new是c++中的运算符
    - new在申请内存的时候会调用构造函数
    - 对于非内部数据类型对象而言，光用malloc是无法满足动态对象的要求的，因为对象在创建的时候要执行构造函数，对象在消亡之前要执行析构函数，由与malloc是库函数而不是运算符，不在编译器控制权限内，不能把执行构造函数和析构函数的任务强加malloc
    - new操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存

13. 形参加const的优点

14. c++内存分区

    - 代码区
    - 静态存储区
    - 栈区
    - 堆区
    - 常量存储区

15. vector的扩容原理

    如果集合已满，在新增数据的时候，需要分配一块更大的内存，将原来的数据复制过来，释放之前的内存

16. C++的单例模式

    ```c++
    class Singleton
    {
        private:
        	static Singleton *instance;
        private:
        	Singleton(){};
            ~Singleton() {};
            Singleton(const Singleton&);
             Singleton& operator=(const Singleton&);
        public:
        	 static Singleton* getInstance()
             {
                 if(instance == nullptr)
                     	instance = new Singleton();
                 return instance;
             }
        
    }
    
    // init static member
    Singleton* Singleton::instance = nullptr;
    ```

17. map的实现原理与红黑树的特点

    底层实现为红黑树

18. extern "C"的作用

    为了能够正确实现C++代码调用C语言代码，加上extern "C"后，会指示编译器这部分代码按C语言的方式进行编译

19. 多态

    “一个接口，多种方法”，多态性是指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作

    - 静态多态 函数重载
    - 动态多态 通过虚函数实现

20. 指针常量与常量指针

    指针常量是指指针本身的值是个常量，常量指针是指指针指向的变量是个常量

21. 内存对齐是什么及其实现原理

    对于结构体变量内存对齐遵循以下三个原则：

    - 变量的起始地址能够被其对齐值整除，结构体变量的对齐值为最宽的成员大小
    - 结构体每个成员相对于起始地址的偏移能够被其自身对齐值整除，如果不能则在前一个成员后面补充字节
    - 结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节

    为什么要内存对齐？

    - 为了减少使用的内存
    - 为了提升数据读取的效率

22. 函数调用怎么实现的，有什么特点

    通过系统栈实现，由操作系统管理，先进后出的特点

23. const的作用

    const指定一个语义结束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的

    - const修饰普通类型的变量
    - const修饰指针变量
    - const参数传递和函数返回值
    - const修饰成员函数

24. 智能指针

25. 大端小端以及如何检测

    小端存储第一个字节是它的低位字节，大端存储第一个字节是高位字节，大端存储因为第一个字节就是高位，从而很容易知道它是正数还是负数，对于一些数值判断会很迅速，而小端存储第一个字节是低位字节，符号位在最后一个字节，做数值四则运算时从低位每次取出相应字节运算，最后直到低位，并且最终把符号位刷新，这样的运算方式会很高效

26. sizeof与strlen的区别

27. C++如何处理异常，异常向上抛出，抛到最上层是什么情况

28. 宏和内联函数

29. 进程地址空间内存分配

30. strcopy、memcopy、memmove