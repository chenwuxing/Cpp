# C++开发岗面试题

## <font color=red>C++常见面试题</font>

1. 智能指针的作用

   将一般类型的指针包装成对象类型，利用对象生命周期到期时会调用析构函数自动完成资源的释放，防止内存泄露

2. 纯虚函数的作用和实现方式

   纯虚函数的作用是作为一个接口，子类必须实现这个接口，以表现出同一个接口却有不同的呈现，实现方式便是在纯虚函数的声明是在虚函数的声明后面加=0

3. STL数据结构的内部实现

   - 线性数据结构
     - vector 数组
     - array 数组
     - list 双向链表
     - forward_list 链表
     - deque 多段连续数组
   - 关联型数据结构
     - map 红黑树（键不重复）
     - multimap 红黑树（键可重复）
     - set 红黑树 （键不重复）
     - multiset 红黑树 （键可重复）
   - 无序型数据结构
     - unordered_map 哈希表（键不重复）
     - unordered_multimap 哈希表 （键可重复）
     - unordered_set 哈希表 （键不重复）
     - unordered_multiset 哈希表 （键可重复）

4. 红黑树插入和和红黑树的用途

   红黑树实现了查找与修改的平衡

5. C、C++的区别以及C++的优势

   c++相当于c语言来说像一个语言联邦，它包含了c语言、面向对象、泛型编程、STL等成分，我暂时不知道如何何时的说出c++的优势，可能更简洁？

6. C++11的新特性有哪些？

   1. lambda表达式
   2. 智能指针
   3. 函数式编程
   4. tuple
   5. 类型转换
   6. 右值引用与移动构造函数
   7. 略略略

7. 指针和引用的区别

   |         引用         |     指针     |
   | :------------------: | :----------: |
   |      必须初始化      | 可以不初始化 |
   |       不能为空       |   可以为空   |
   | 不能重新绑定其他对象 | 可以更换目标 |

   

8. 智能指针的底层实现

9. 虚函数的底层实现

   虚指针加虚函数表

10. define的特点，预处理进行替换及define的优缺点

    - define在编译的预处理阶段起作用
    - define只是简单的字符串替换，没有类型检查
    - define是不能调试的

11. static作用

    - 修饰局部变量，使其生命周期持续到程序结束，且只有一次的初始化，存储于静态存储区
    - 修饰全局变量，使变量仅在当前文件可见
    - 修饰一般函数，使函数仅在当前文件可见
    - 修饰类成员变量，使其所有权属于类，所有对象使用同一个成员变量
    - 修饰成员函数，同上

12. new和malloc的区别

    - malloc是c的库函数，new是c++中的运算符
    - new在申请内存的时候会调用构造函数
    - 对于非内部数据类型对象而言，光用malloc是无法满足动态对象的要求的，因为对象在创建的时候要执行构造函数，对象在消亡之前要执行析构函数，由与malloc是库函数而不是运算符，不在编译器控制权限内，不能把执行构造函数和析构函数的任务强加malloc
    - new操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存

13. 形参加const的优点

14. c++内存分区

    - 堆区
    - 栈区
    - 代码区
    - 全局/静态存储区
    - 常量存储区

15. vector的扩容原理

    如果集合已满，在新增数据的时候，需要分配一块更大的内存，将原来的数据复制过来，释放之前的内存

16. C++的单例模式

    ```c++
    class Singleton
    {
        private:
        	static Singleton *instance;
        private:
        	Singleton(){};
            ~Singleton() {};
            Singleton(const Singleton&);
             Singleton& operator=(const Singleton&);
        public:
        	 static Singleton* getInstance()
             {
                 if(instance == nullptr)
                     	instance = new Singleton();
                 return instance;
             }
        
    }
    
    // init static member
    Singleton* Singleton::instance = nullptr;
    ```

17. map的实现原理与红黑树的特点

    底层实现为红黑树

18. extern "C"的作用

    为了能够正确实现C++代码调用C语言代码，加上extern "C"后，会指示编译器这部分代码按C语言的方式进行编译

19. <font color=red>多态</font>

    “一个接口，多种方法”，多态性是指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作

    - 静态多态 函数重载
    - 动态多态 通过虚函数实现

20. 指针常量与常量指针

    指针常量是指指针本身的值是个常量，常量指针是指指针指向的变量是个常量

21. 内存对齐是什么及其实现原理

    对于结构体变量内存对齐遵循以下三个原则：

    - 变量的起始地址能够被其对齐值整除，结构体变量的对齐值为最宽的成员大小
    - 结构体每个成员相对于起始地址的偏移能够被其自身对齐值整除，如果不能则在前一个成员后面补充字节
    - 结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节

    为什么要内存对齐？

    - 为了减少使用的内存
    - 为了提升数据读取的效率

22. 函数调用怎么实现的，有什么特点

    通过系统栈实现，由操作系统管理，先进后出的特点

23. const的作用

    const指定一个语义结束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的

    - const修饰普通类型的变量
    - const修饰指针变量
    - const参数传递和函数返回值
    - const修饰成员函数

24. 智能指针

25. 大端小端以及如何检测

    小端存储第一个字节是它的低位字节，大端存储第一个字节是高位字节，大端存储因为第一个字节就是高位，从而很容易知道它是正数还是负数，对于一些数值判断会很迅速，而小端存储第一个字节是低位字节，符号位在最后一个字节，做数值四则运算时从低位每次取出相应字节运算，最后直到低位，并且最终把符号位刷新，这样的运算方式会很高效

26. sizeof与strlen的区别

    sizeof是求数据类型所占的空间，而strlen是求字符串的长度，字符串以'\0'结尾

27. C++如何处理异常，异常向上抛出，抛到最上层是什么情况

28. 宏和内联函数

    二者都是为了降低函数调用所带来的开销，宏在调用的地方，仅仅是简单的代码替换，所以参数要用括号括起来，不会出现函数调用那种压栈、出栈时的时间和空间的开销，执行效率更高

    内联函数是代码被插入到调用者代码处的函数，但和宏的区别是宏由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的，而且内联函数是真正的函数调用，只是在需要用到的时候，内联函数像宏一样展开，所以取消了函数的参数压栈，减少了调用的开销

29. 进程地址空间内存分配

30. strcopy、memcopy、memmove

31. 类型转换

    - const_cast
    - static_cast
    - dynamic_cast
    - reinterpret_cast

32. 隐式类型转换以及如何避免隐式类型转换

    可以用单个形参来调用的构造函数定义了从形参类型到该类类型的一个隐式转换，可以用explicit

33. 手写atoi

34. 函数压栈的过程

35. 重载与重写的区别

    重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义不相同

    重写是指面向对象中的多态，子类重写基类中的虚函数，从而表现出一个接口，多种呈现的现象

36. 模板为什么声明和定义要放在一个文件里

    因为当实例化一个模板时，编译器必须看到模板确切的定义，而不仅仅是它的声明

37. STL空间配置器如何处理内存？大致的实现方案以及为什么是8字节的倍数

38. 手写一个有可变参数的函数

39. 指针和数组的关系

    联系

    - 数组名作为右值时代表数组首元素的首地址
    - 当数组作为形参传递给函数时，实际会退化为指针

    区别

    - 指针是表示内存地址的数据类型
    - 数组则表示有序的元素序列

40. 虚函数表在什么时候创建，以及创建在哪个位置

    程序编译阶段，常量区

41. 迭代器类型有哪些?

    - output iterator

    - input iterator
    - forward iterator
    - bidirectional iterator
    - random access iterator

42. std::bind与std::function

43. 移动语义

44. RAII(Resource Acquisition Is Initialization)资源获取初始化

    资源的有效期与持有资源的对象的生命期严格绑定，即由对象的构造函数完成资源的分配，同时由对象的析构函数完成资源的释放，在这种情况下，只要对象能正确地析构，就不会出现资源泄露问题

45. RTII(Runtime Type Information)

    运行时类型识别，主要由以下三部分组成：

    - type_info类

    - typeid操作符

      如果表达式的类型是类类型且至少包含有一个虚函数，则typeid操作符返回表达式的动态类型，需要在运行时计算；否则，typeid操作符返回表达式的静态类型，在编译时就可以计算

    - type_index类

46. 值语义与对象语义

47. C和C++中的struct区别

    |                          C                           |                             C++                              |
    | :--------------------------------------------------: | :----------------------------------------------------------: |
    |               不能将函数放在结构体声明               |                    能将函数放在结构体声明                    |
    |         在C结构体声明中不能使用C++访问修饰符         |                      可以使用访问修饰符                      |
    | 在C中定义结构体变量，如果使用了下面定义必须加struct  |                        可以不加struct                        |
    |                    结构体不能继承                    |                           可以继承                           |
    | 若结构体的名字与函数名相同，可以正常运行且正常的调用 | 若结构体的名字与函数名相同，使用结构体，只能使用带struct定义 |

48. 在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为 virtual 吗？如果不申明为 virtual 会怎样？

    在单继承体系内，若要经由指向基类的指针销毁派生类部分，不管派生类是virtual还是non-virtual析构函数，其基类必须带有virtual析构函数



## <font color=red>计算机网络常考面试题</font>

1. <font color=blue>TCP连接为什么是三次握手？</font>

   ① <font color=red> 为了使客户端与接收端都能确认自己和对方的发送能力与接收能力没有问题</font>

   ②<font color=red>  TCP是基于字节流的传输协议，通信双方都维护一个序列号，以表示已发送的数据包中，哪些是已经被对方接收的，三次握手的过程即是客户端与服务端互相交换初始序列号的过程，如果只是两次握手，则只有连接发起方的初始序列号能被确认，另一方的初始序列号不能得到确认</font>

   |  视角  | 客收 | 客发 | 服收 | 服发 |
   | :----: | :--: | :--: | :--: | :--: |
   | 客户端 |  ②   | ①+②  | ①+②  |  ②   |
   | 服务端 | ②+③  |  ①   |  ①   | ②+③  |

2. <font color=blue>为什么TCP四次挥手时等待为2MSL？</font>

   <font color=red>如果不等，释放的端口可能会重连刚断开的服务器端口，这样会使依然活跃在网络里的旧的TCP报文与新的TCP连接报文形成数据冲突，为避免这种情况，需要等待2MSL，这样会使旧的连接中的报文全部灭亡，避免上述情形</font>

3. 





































